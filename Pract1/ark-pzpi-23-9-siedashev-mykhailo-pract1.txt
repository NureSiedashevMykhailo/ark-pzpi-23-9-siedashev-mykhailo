МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмна інженерія»

ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»

на тему «Правила оформлення програмного коду мовою С++ за Google C++ Style Guide та C++ Core Guidelines»

Виконав:
ст. гр. ПЗПІ-23-8
Корякін З. П.

Прийняв:
Старший викладач каф. ПІ
Сокорчук І. П.

Харків 2025

------------------------------------------------------------------

1. МЕТА РОБОТИ

Ознайомити студентів з провідними індустріальними стандартами оформлення коду мовою C++, зокрема Google C++ Style Guide та C++ Core Guidelines.
Навчити застосовувати правила іменування змінних, функцій та типів даних для підвищення читабельності коду.
Сформувати навички написання безпечного коду (Memory Safety, Type Safety) шляхом відмови від застарілих конструкцій мови C (C-style casts, raw pointers, NULL) на користь сучасних механізмів C++ (Smart Pointers, static_cast, nullptr).
Розвинути вміння аналізувати чужий код та проводити його рефакторинг відповідно до обраних стайлгайдів.

2. ІСТОРІЯ ЗМІН

№    Дата        Версія    Опис змін та виправлень
1    03.12.2025  v. 1.0    Створено розділ «Мета роботи»
2    03.12.2025  v. 1.0    Створено розділ «Історія змін»
3    03.12.2025  v. 1.0    Створено розділ «Хід роботи» з аналізом правил
4    03.12.2025  v. 1.0    Створено розділ «Висновки»
5    03.12.2025  v. 1.0    Створено розділ «Використані джерела»
6    03.12.2025  v. 1.0    Створено додатки А та Б

3. ХІД РОБОТИ

Вступ

У цьому розділі розглянуто важливість уніфікації стилю коду в командній розробці. Google C++ Style Guide фокусується на узгодженості (consistency) та читабельності, визначаючи чіткі правила форматування та іменування. C++ Core Guidelines (розроблені Б'ярном Страуструпом та Гербом Саттером) фокусуються на написанні коректного, ефективного та безпечного коду.

У роботі проаналізовано та застосовано 10 ключових рекомендацій для покращення якості C++ коду.

1. Іменування (Naming Conventions)

Правило: Використовувати чіткі угоди про іменування для розрізнення типів, змінних та функцій.
- Змінні: snake_case (наприклад, days_since_creation).
- Типи/Класи: CamelCase (наприклад, AccountManager).

Код до рефакторингу:
int d; // elapsed days
class manager { int Val; };

Після рефакторингу:
int days_since_creation;
class AccountManager { int balance_amount; };

2. Структура коду та відступи

Правило: Код повинен бути структурованим, з відступами (зазвичай 2 або 4 пробіли) та пробілами навколо операторів для читабельності.

Код до рефакторингу:
if(x){func();return;}else{do_other();}

Після рефакторингу:
if (x) {
    func();
    return;
} else {
    do_other();
}

3. Сучасна робота з пам'яттю (Smart Pointers)

Правило: Уникати "сирих" вказівників (new/delete). Використовувати std::unique_ptr та std::make_unique для автоматичного керування пам'яттю.

Код до рефакторингу:
void unsafe() {
    User* u = new User();
    if (error()) return; // Витік пам'яті!
    delete u;
}

Після рефакторингу:
void safe() {
    auto u = std::make_unique<User>();
    if (error()) return;
    // Пам'ять звільняється автоматично
}

4. Const Correctness (Константна коректність)

Правило: Робити об'єкти та методи незмінними (const) за замовчуванням, якщо вони не повинні змінювати стан.

Код до рефакторингу:
// Функція може випадково змінити рядок
void print(std::string& str) {
    std::cout << str;
}

Після рефакторингу:
// Гарантія, що str не зміниться
void print(const std::string& str) {
    std::cout << str;
}

5. RAII (Resource Acquisition Is Initialization)

Правило: Ресурси (файли, м'ютекси) повинні керуватися об'єктами. Захоплення в конструкторі, звільнення в деструкторі.

Код до рефакторингу:
m.lock();
process(); // Якщо тут exception, unlock не спрацює
m.unlock();

Після рефакторингу:
{
    std::lock_guard<std::mutex> lk(m); // Автоматичний lock
    process();
} // Автоматичний unlock

6. Обробка помилок

Правило: Використовувати виключення (try-catch) замість кодів повернення для обробки нештатних ситуацій.

Код до рефакторингу:
int res = calculate();
if (res == -1) handle_error();

Після рефакторингу:
try {
    calculate();
} catch (const std::exception& e) {
    std::cerr << "Error: " << e.what();
}

7. Продуктивність (References vs Copies)

Правило: Передавати важкі об'єкти (вектори, рядки) за константним посиланням, щоб уникнути зайвого копіювання.

Код до рефакторингу:
// Копіює весь вектор при виклику
void process(std::vector<int> data);

Після рефакторингу:
// Передає лише адресу
void process(const std::vector<int>& data);

8. Безпечне приведення типів (Casting)

Правило: Використовувати C++ casts (static_cast, dynamic_cast) замість C-style casts ((int)x) для безпеки та пошуку помилок компілятором.

Код до рефакторингу:
Base* b = (Base*)derived_ptr; // Небезпечно

Після рефакторингу:
Base* b = static_cast<Base*>(derived_ptr); // Безпечно

9. Використання nullptr

Правило: Використовувати nullptr замість NULL або 0 для вказівників, щоб уникнути плутанини з цілими числами.

Код до рефакторингу:
func(NULL); // Може викликати func(int)

Після рефакторингу:
func(nullptr); // Однозначно викликає func(ptr)

10. Простори імен (Namespaces)

Правило: Не використовувати using namespace std; у глобальному просторі імен, щоб уникнути конфліктів імен.

Код до рефакторингу:
using namespace std;
int count() { return 0; } // Конфлікт з std::count

Після рефакторингу:
void print() {
    std::cout << "Hello"; // Явне вказання
}

4. ВИСНОВКИ

У ході виконання роботи було проаналізовано та застосовано на практиці 10 ключових правил оформлення коду згідно з Google C++ Style Guide та C++ Core Guidelines.
Було встановлено, що комплексний підхід, який включає правильне іменування, автоматичне керування пам'яттю (Smart Pointers), безпеку типів та константну коректність, дозволяє створювати надійне програмне забезпечення, стійке до помилок та зручне для підтримки.

5. ВИКОРИСТАНІ ДЖЕРЕЛА

1. Google C++ Style Guide. URL: https://google.github.io/styleguide/cppguide.html
2. C++ Core Guidelines (Stroustrup & Sutter). URL: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
3. Scott Meyers, "Effective Modern C++".
4. Довідник cppreference.com.

ДОДАТОК А
Посилання на репозиторій

(Тут має бути посилання на GitHub репозиторій з кодом)

ДОДАТОК Б
Матеріали презентації

Рисунок Б.1 - Титульний слайд
Рисунок Б.2 - Іменування та Структура
Рисунок Б.3 - Пам'ять та RAII
Рисунок Б.4 - Const Correctness та Продуктивність
Рисунок Б.5 - Безпека типів, nullptr та Namespaces
Рисунок Б.6 - Висновки